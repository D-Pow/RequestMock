<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Home - Documentation</title>
    
    <meta name="description" content="MockRequests will mock both XMLHttpRequest and fetch such that any requested URL will return the specified mock object instead of actually making an async request. URLs not configured will be unaffected and still trigger an async request as normal." />
    
        <meta name="keywords" content="request HTTP requests XMLHttpRequest fetch mock mocks network" />
        <meta name="keyword" content="request HTTP requests XMLHttpRequest fetch mock mocks network" />
    
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h2><a href="./demo" >Demo</a></h2><h2><a href="https://www.npmjs.com/package/mock-requests" >npm</a></h2><h2><a href="https://github.com/D-Pow/MockRequests" >GitHub</a></h2><h3>Modules</h3><ul><li><a href="module-mock-requests.html">mock-requests</a></li><li><a href="module-mock-requests_bin.html">mock-requests/bin</a></li></ul><h3>Namespaces</h3><ul><li><a href="MockRequests.html">MockRequests</a><ul class='methods'><li data-type='method'><a href="MockRequests.html#.configure">configure</a></li><li data-type='method'><a href="MockRequests.html#.configureDynamicResponses">configureDynamicResponses</a></li><li data-type='method'><a href="MockRequests.html#.setMockUrlResponse">setMockUrlResponse</a></li><li data-type='method'><a href="MockRequests.html#.setDynamicMockUrlResponse">setDynamicMockUrlResponse</a></li><li data-type='method'><a href="MockRequests.html#.getResponse">getResponse</a></li><li data-type='method'><a href="MockRequests.html#.deleteMockUrlResponse">deleteMockUrlResponse</a></li><li data-type='method'><a href="MockRequests.html#.clearAllMocks">clearAllMocks</a></li><li data-type='method'><a href="MockRequests.html#.mapStaticConfigToDynamic">mapStaticConfigToDynamic</a></li></ul></li><li><a href="resolve-mocks.html">resolve-mocks</a><ul class='methods'><li data-type='method'><a href="resolve-mocks.html#.resolveMocks">resolveMocks</a></li></ul></li></ul><h3>Classes</h3><ul><li><a href="MockRequestsWebpackPlugin.html">MockRequestsWebpackPlugin</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<div id="main">
    

    



    


    <section class="package">
        <h3> </h3>		
    </section>









    



    <section class="readme">
        <article><h1 id="mockrequests">MockRequests</h1>
<p><a href="https://travis-ci.org/D-Pow/MockRequests"><img src="https://travis-ci.org/D-Pow/MockRequests.svg?branch=master" alt="build status"></a>
<a href="https://coveralls.io/github/D-Pow/MockRequests?branch=master"><img src="https://coveralls.io/repos/github/D-Pow/MockRequests/badge.svg?branch=master" alt="coverage status"></a>
<a href="https://packagephobia.now.sh/result?p=mock-requests"><img src="https://packagephobia.now.sh/badge?p=mock-requests" alt="install size"></a></p>
<p>Mocks network requests with desired static and dynamic responses automatically so you
never have to change your source code to use mocks ever again.</p>
<h4 id="backed-and-used-by%3A">Backed and Used by:</h4>
<ul>
<li><a href="https://us.etrade.com"><img src="https://cdn2.etrade.net/1/17092613100.0/aempros/content/dam/etrade/retail/en_US/images/global/logos/etrade-logo-rgb-144x22.svg" alt="E-Trade" style="background: white; padding: 5px" /></a></li>
<li><a href="https://nextdoor.com"><img src="https://d19rpgkrjeba2z.cloudfront.net/static/gen/fe6b9b01b5aca5e163e08ecc131c3446.svg" alt="Nextdoor" style="background: white; padding: 5px" /></a></li>
</ul>
<h2 id="contents">Contents</h2>
<ul>
<li><a href="#features">Features</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#usage">Usage</a>
<ul>
<li><a href="#quick-note-about-usage-in-back-end-or-nodejs-scripts">Quick note about usage in back-end or NodeJS scripts</a></li>
</ul>
</li>
<li><a href="#examples">Examples</a>
<ul>
<li><a href="#static-responses">Static responses</a>
<ul>
<li><a href="#basic-configuration">Basic configuration</a></li>
<li><a href="#mixing-mocks-with-actual-api-calls">Mixing mocks with actual API calls</a></li>
</ul>
</li>
<li><a href="#dynamic-responses">Dynamic responses</a>
<ul>
<li><a href="#modifying-responses-by-payload">Modifying responses by payload</a></li>
<li><a href="#modifying-responses-by-query-parameters">Modifying responses by query parameters</a></li>
<li><a href="#delaying-resolution-time">Delaying resolution time</a></li>
</ul>
</li>
<li><a href="#mocks-based-on-different-logins">Mocks based on different logins</a></li>
<li><a href="#other-utility-functions">Other utility functions</a></li>
</ul>
</li>
<li><a href="#separating-mocks-from-source-code">Separating mocks from source code</a>
<ul>
<li><a href="#bare-bones-instructions">Bare-bones instructions</a></li>
<li><a href="#webpack-pluginactivating-via-cli">Webpack Plugin/Activating via CLI</a>
<ul>
<li><a href="#plugin-options">Plugin options</a></li>
</ul>
</li>
<li><a href="#further-customization">Further customization</a></li>
</ul>
</li>
<li><a href="#mockrequests-api">MockRequests API</a></li>
<li><a href="#implementation-notes">Implementation notes</a></li>
<li><a href="#license">License</a></li>
</ul>
<h2 id="features">Features</h2>
<p>This library was made for the purpose of allowing developers to be able to continue to write code
as normal even when their APIs are down, haven't been developed by back-end teams yet, or don't have
internet at all. It provides a quick, single point of entry that can be called once and will work
throughout your entire app.</p>
<p>In particular, most other network-mocking libraries are not user friendly in that they either:</p>
<ul>
<li><em>Force users to re-write</em> their source code to use mocks and then <em>change it back later</em> in order
to use real network requests, or</li>
<li>Involve <em>complex setup</em> using local servers and proxies, usually in ways that are app-specific and aren't easily
transferable to other projects.</li>
</ul>
<p>This library differs from the others in that it allows you to continue <strong>writing code as normal</strong> while still
using mock network activity.</p>
<p>Specific benefits provided by this library that aren't offered in others:</p>
<ul>
<li>You <strong>never have to change your source code</strong>. This means no more replacing
<code>fetch()</code> with <code>Promise.resolve(mockResponse)</code>, and no changing URLs from <code>website.com/api</code> to <code>third-party-mocks.com/api</code>.</li>
<li><strong>No painful configuration</strong> of complex node servers, proxies, or anything else to host mock data.
This also means no need to change URLs from <code>website.com/api</code> to <code>localhost/api</code>.</li>
<li>Full support for <strong>use along with third-party libraries</strong>, including <a href="https://github.com/axios/axios">Axios</a> and
<a href="https://github.com/facebook/jest">jest</a>, so they function as normal while still giving you the mocks you want.</li>
<li><strong>Dynamically update mock responses</strong> based on request payloads, previous mock responses, and query parameters in
order to mimic back-end alterations of data.</li>
<li>Query parameter parsing so you can <strong>mock all URLs with the same pathname</strong> using the same dynamic response function.</li>
<li>Customizable <strong>mock response delays</strong> to mimic natural network resolution times.</li>
<li><strong>Mix mocks with real API calls</strong> so you can use both functional and non-functional endpoints simultaneously.</li>
<li>Simple configuration to <strong>split mock code from production code</strong> and/or <strong>activate mocks via terminal</strong> (e.g. <code>MOCK=true npm start</code>).</li>
<li>No confusing interfaces or multi-step procedures to getting started. Simply <strong>configure it once</strong> and you're good to go.
This becomes extremely useful if you want to <strong>switch app-wide mocks between different logins</strong> when developing.</li>
<li><strong>Greatly simplify API testing</strong>. Just define <code>fetch</code> and/or <code>XMLHttpRequest</code> in a test setup file and configure
<code>MockRequests</code> with the responses you expect. It will handle all the heavy-lifting of mocking network responses for you
so you don't have to repetitively use e.g. <code>fetch = jest.fn()</code>. See an example of the one-and-done <a href="https://github.com/D-Pow/MockRequests/blob/master/demo/package.json#L55">configuration</a> and <a href="https://github.com/D-Pow/MockRequests/blob/master/demo/tests/services/Kitsu.spec.js">testing</a> in the <a href="./demo">demo</a>.</li>
<li>Compatible with <strong>all JavaScript environments</strong>, including back-end Node scripts, as long as either <code>fetch</code> or
<code>XMLHttpRequest</code> are defined and used in that environment (natively or by polyfill).</li>
</ul>
<h2 id="installation">Installation</h2>
<ul>
<li>
<p>Using npm (see the <a href="https://www.npmjs.com/package/mock-requests">npm package</a>):</p>
<p><code>npm install --save-dev mock-requests</code></p>
</li>
<li>
<p>Using git:</p>
<ul>
<li>
<p>Via npm:</p>
<p><code>npm install --save-dev https://github.com/D-Pow/MockRequests.git</code></p>
</li>
<li>
<p>With locally installed repo:</p>
<p><code>git clone https://github.com/D-Pow/MockRequests.git</code></p>
<p>package.json:</p>
<p><code>&quot;mock-requests&quot;: &quot;file:&lt;pathToCloneLocation&gt;/MockRequests</code></p>
</li>
</ul>
</li>
</ul>
<h2 id="usage">Usage</h2>
<p>API docs can be viewed in the <a href="https://d-pow.github.io/MockRequests/MockRequests.html">JSDoc</a> along with
a <a href="https://d-pow.github.io/MockRequests/demo/">live demo</a>.</p>
<p>This library wraps <code>XMLHttpRequest</code> and <code>fetch</code> such that any network request to a configured
URL will return the specified mock response instead of actually making the network requests.
Otherwise, if a URL hasn't been configured with a mock response, the standard async request is made.</p>
<p><code>MockRequests</code> was designed to be used in such a way that wherever you configure it, the entire app
experiences the effects. This means you could configure it in one file and then all other files
that make network requests to the configured URLs will receive the mock responses instead,
even without importing <code>MockRequests</code>. This makes it very easy to work on the front-end even if
some APIs are down, haven't been developed yet, or if you have no internet access at all.</p>
<h3 id="quick-note-about-usage-in-back-end-or-nodejs-scripts">Quick note about usage in back-end or NodeJS scripts</h3>
<p>TL;DR: <strong>It is highly recommended to use <a href="https://www.npmjs.com/package/isomorphic-fetch">isomorphic-fetch</a></strong> for any back-end/NodeJS scripts since it &quot;just works&quot; throughout your entire app just like MockRequests does.</p>
<details>
    <summary>Network requests in general</summary>
<p>MockRequests generally works with any third-party library because it doesn't alter the library itself, it only changes how <code>fetch</code>/<code>XMLHttpRequest</code> work. As such, <code>jest</code>, <code>axios</code>, etc. aren't affected since they only provide wrappers around the above without changing how they work.</p>
<p>However, MockRequests relies on those network functions being defined globally <strong>before being imported</strong>. So, if using a library that modifies those functions/objects, like <a href="https://www.npmjs.com/package/node-fetch"><code>node-fetch</code></a> does, you must <em>heed their warnings</em> to <a href="https://github.com/node-fetch/node-fetch/blob/37ac459cfd0eafdf5bbb3d083aa82f0f2a3c9b75/README.md#providing-global-access">add <code>fetch</code>, <code>Headers</code>, etc. as global variables</a> <strong>before</strong> importing/<code>require</code>-ing MockRequests. In fact, this is exactly what <code>isomorphic-fetch</code> does - it imports <code>node-fetch</code> and then sets all the global variables for you (just like <code>node-fetch</code> itself recommends) so you don't have to.</p>
<p>In other words, this is the easiest way to make (and mock) network requests:</p>
<pre class="prettyprint source lang-javascript"><code>// [any].mjs
import 'isomorphic-fetch'; // Automatically mocks `fetch()` globally for all files!
import MockRequests from 'mock-requests';

MockRequests.configure({
    [apiUrl]: { myKey: 'myVal' },
});

fetch(apiUrl); // Mocked easily and automatically!
</code></pre>
<p>as opposed to being forced to call <code>global.fetch()</code> instead of <code>fetch()</code>:</p>
<pre class="prettyprint source lang-javascript"><code>// app.mjs
import * as NodeFetch from 'node-fetch';
// Don't import `fetch`/`Headers` individually to avoid polluting the script's namespace.
// Otherwise, you'd have to use `global.fetch(url, options)` so `global.fetch` is used
// rather than the local `fetch` function.
global.fetch = NodeFetch.default;
global.Headers = NodeFetch.Headers;

// Force `global[field] = field` to be set before importing MockRequests
const MockRequests = (await import('mock-requests')).default;

fetch(apiUrl); // Mocked, but cumbersome to setup. Same regardless of MJS or CJS.



// app.cjs equivalent

/* node-fetch@>=3 */
const NodeFetch = await import('node-fetch');
// Same concept as in MJS: Don't pollute the namespace to use `global.fetch` by default
global.fetch = NodeFetch.default;
global.Headers = NodeFetch.Headers;

const MockRequests = require('mock-requests');
// ... mock configuration/network calls

/* node-fetch@&lt;=2 */
global.fetch = require('node-fetch');
global.Headers = fetch.Headers;

const MockRequests = require('mock-requests');
// ... mock configuration/network calls
</code></pre>
<p>or, alternatively, being forced to extract the polyfills to a separate file:</p>
<pre class="prettyprint source lang-javascript"><code>// NetworkPolyfill.mjs
import fetch, { Headers } from 'node-fetch';

global.fetch = fetch;
global.Headers = Headers;


// app.mjs
import './NetworkPolyfill.js'; // Must be imported before MockRequests
import MockRequests from 'mock-requests';

MockRequests.configureDynamicResponses(...);

fetch(apiUrl); // Mocked, but requires splitting of network-setup logic to a separate file.
</code></pre>
</details>
<details>
    <summary>Network requests using Axios in NodeJS</summary>
<p>Currently, MockRequests only mocks <code>fetch</code> and <code>XMLHttpRequest</code>. When used in NodeJS scripts, Axios attempts using XHR first and falls back to using the NodeJS <code>http</code>/<code>https</code> modules if it doesn't exist (<a href="https://github.com/axios/axios/blob/master/lib/defaults.js#L17-L27">source code ref</a>). Thus, an XHR polyfill must be added to use Axios in the live NodeJS code (but not Jest tests, as described in <a href="#features">Features</a>).</p>
<p>Furthermore, there is a <a href="https://github.com/D-Pow/MockRequests/issues/15#issuecomment-891205355">bug in the NodeJS <code>xmlhttprequest</code> package</a> caused by them not following the <a href="https://xhr.spec.whatwg.org">correct WHATWG standard</a>. Until MockRequests adds native support for the NodeJS <code>http</code>/<code>https</code> modules, an XHR polyfill library (like the one mentioned here) will have to be used in order to use <code>Axios</code> in back-end source code. In order to do so, write your code in a similar fashion to that described above:</p>
<pre class="prettyprint source lang-javascript"><code>/* app.mjs */
// Don't pollute namespace by using dynamic imports
global.XMLHttpRequest = (await import('xmlhttprequest')).XMLHttpRequest;
// Force global fields to be defined before defining MockRequests and Axios
const MockRequests = (await import('mock-requests')).default;
const axios = (await import('axios')).default;
// ... your logic


/* app.js */
// First, the polyfill
global.XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;
// Next, MockRequests
const MockRequests = require('mock-requests');
// Finally, Axios
const axios = require('axios');
// ... your logic
</code></pre>
</details>
<h2 id="examples">Examples</h2>
<p>Note how in the below examples, the <strong>production-bound code doesn't change</strong> between
mocking and using network calls.</p>
<h3 id="static-responses">Static responses</h3>
<h4 id="basic-configuration">Basic configuration</h4>
<p>To configure global app usage of <code>MockRequests</code>, simply call <code>configure()</code> with an object containing URL-responseObject
mappings.</p>
<pre class="prettyprint source lang-javascript"><code>// This is the only code you need to add to use this library
// Add in the MockConfig.js file described in the &quot;Separating
// mocks from source code&quot; section
import MockRequests from 'mock-requests';
import {
    myApiUrl,   // 'https://example.com/api/vx/someApi'
    anotherUrl  // '192.168.0.1'
} from '../src/services/Urls.js';

const myApiMockResponse = { someJson: 'responseObject' };
const anotherUrlMockResponse = '&lt;html>some other type of response&lt;/html>';

MockRequests.configure({
    [myApiUrl]: myApiMockResponse,
    [anotherUrl]: anotherUrlMockResponse
});

// ...source code

// Using your async requests in source code
// This stays the same regardless of if you're using mocks or the actual endpoint
const jsonResponse = await fetch(myApiUrl).then(res => res.json());
const htmlResponse = await fetch(anotherUrl).then(res => res.text());

useResponseContentAsNormal(jsonResponse);
useResponseContentAsNormal(htmlResponse);
</code></pre>
<p>Alternatively, you could configure URL-response content individually:</p>
<pre class="prettyprint source lang-javascript"><code>// same URLs and mock responses from above
import MockRequests from 'mock-requests';

MockRequests.setMockUrlResponse(myApiUrl, myApiMockResponse);
MockRequests.setMockUrlResponse(anotherUrl, anotherUrlMockResponse);
</code></pre>
<h4 id="mixing-mocks-with-actual-api-calls">Mixing mocks with actual API calls</h4>
<p>In the event that some APIs are not functioning correctly but others are, you can configure
the broken APIs using <code>MockRequests</code> and then leave the other APIs as-is for normal responses:</p>
<pre class="prettyprint source lang-javascript"><code>import MockRequests from 'mock-requests';
import { nonfunctionalApi } from '../src/services/Urls.js';

MockRequests.setMockUrlResponse(nonfunctionalApi, /* mock response */);

// ...source code

// Will receive mock
const mockedResponse = await fetch(nonfunctionalApi).then(res => res.json());
// Will receive actual API response
const realApiResponse = await fetch(functionalApi).then(res => res.json());

useResponseContent(mockedResponse);
useResponseContent(realApiResponse);
</code></pre>
<h3 id="dynamic-responses">Dynamic responses</h3>
<h4 id="modifying-responses-by-payload">Modifying responses by payload</h4>
<p>This library also supports dynamically updating your mocked APIs' responses, so as to mimic actual
back-end systems. To utilize this feature, you'll need to call the dynamic counterparts of
<code>configure/setMockUrlResponse</code> (<code>configureDynamicResponses/setDynamicMockUrlResponse</code>) along with
a slightly modified config object that has <code>response</code> and <code>dynamicResponseModFn</code> fields:</p>
<pre class="prettyprint source lang-javascript"><code>import MockRequests from 'mock-requests';
import { myApiUrl } from '../src/services/Urls.js';

const initialMockResponse = {
    data: ['a', 'b', 'c', 'd', 'e'],
    value: 7
};
const dynamicConfig1 = {
    [myApiUrl]: {
        // The desired response is now nested inside the `response` property.
        // This will be the initial default value of the `response` parameter
        // in the function below, but won't be used after that.
        response: initialMockResponse,
        // The dynamicResponseModFn takes in the request and previous
        // response as arguments to produce the new response.
        // The new response **must** be returned from this function.
        // Feel free to modify `response` as it will be deep-copied later.
        dynamicResponseModFn: (request, response) => {
            // Mix both request and response data to generate new response
            response.data = response.data.concat(request.addLettersArray);
            response.value += request.valueModification;

            return response; // is actually now the new response
        }
    }
};

MockRequests.configureDynamicResponses(dynamicConfig1);

// ...source code

const payload = {
    addLettersArray: ['f', 'g'],
    valueModification: 5
};
const myDynamicallyModifiedResponse = await fetch(myApiUrl, {
    body: JSON.stringify(payload)
}).then(res => res.json());

console.log(myDynamicallyModifiedResponse)

/* Will output:
{
    data: ['a', 'b', 'c', 'd', 'e', 'f', 'g'],
    value: 12
}
*/
</code></pre>
<h4 id="modifying-responses-by-query-parameters">Modifying responses by query parameters</h4>
<p>Additionally, the <code>dynamicResponseModFn</code> will receive an object containing query parameters from the request URL,
which means you also have the option to generate dynamic responses based on those.</p>
<p>If you want to mock all URLs with the same pathname but different query parameters, simply add <code>usePathnameForAllQueries: true</code>
to your dynamic mock configuration.</p>
<p>Regardless of if you set <code>usePathnameForAllQueries</code> or not, <code>dynamicResponseModFn</code> will still receive the <code>queryParamMap</code>.</p>
<pre class="prettyprint source lang-javascript"><code>import {
    searchApiPathname  // 'https://example.com/search'  e.g. search?q=weather
} from '../src/services/Urls.js';

MockRequests.setDynamicMockUrlResponse(searchApiPathname, {
    // `response` field not needed because we don't need an initial `response` value
    dynamicResponseModFn: (request, response, queryParamMap) => {
        const searchQuery = decodeURIComponent(queryParamMap.q);
        return `You searched for ${searchQuery}`;
    },
    usePathnameForAllQueries: true
});

// ...source code

const searchQuery = getSearchFromTextInput(); // let's assume this is `weather`
const searchUrl = `${searchApiPathname}?q=${encodeURIComponent(searchQuery)}`;
const response = await fetch(searchUrl).then(res => res.text());

console.log(response);

/* Will output:
'You searched for weather'
*/
</code></pre>
<h4 id="delaying-resolution-time">Delaying resolution time</h4>
<p>There is also a <code>delay</code> option you can use if you want to mimic network delays:</p>
<pre class="prettyprint source lang-javascript"><code>// or configureDynamicResponses({ [myApiUrl]: {...} })
MockRequests.setDynamicMockUrlResponse(myApiUrl, {
    response: myMockResponse,
    dynamicResponseModFn: (req, res, queries) => {/* ... */},
    delay: 1500   // will make fetch take 1.5 seconds to resolve myApiUrl
});
</code></pre>
<h3 id="mocks-based-on-different-logins">Mocks based on different logins</h3>
<p>Finally, because the <code>configure</code>/<code>setMockUrlResponse</code> functions take in a simple URL-response mapping,
using different mocks at different times becomes incredibly user-friendly. For example,
if your data changes based on which user is logged in, then the <code>MockRequests</code> API is
particularly easy to work with. In this case, after defining each user's mock responses,
you could nest them in a single <code>loginMocks</code> object and simply choose which login to use:</p>
<pre class="prettyprint source lang-javascript"><code>const bobMocks = {
    [homepageUrl]: bobHomepageMock,
    [friendsUrl]: bobFriendsMock
};
const aliceMocks = {
    [homepageUrl]: aliceHomepageMock,
    [friendsUrl]: aliceFriendsMock
};
const loginMocks = {
    bob: bobMocks,
    alice: aliceMocks
};

// Today, I want to be Alice
MockRequests.configure(loginMocks.alice);
// no, wait, I'll be Bob instead
MockRequests.configure(loginMocks.bob);
</code></pre>
<h3 id="other-utility-functions">Other utility functions</h3>
<p>For convenience, a <code>mapStaticConfigToDynamic()</code> function has been included to make converting the above
static version of <code>loginMocks</code> to the dynamic counterpart easier:</p>
<pre class="prettyprint source lang-javascript"><code>// Example 1
// Convert a static URL-response mock to dynamic and add delay to home page
const dynamicBobMocks = MockRequests.mapStaticConfigToDynamic(bobMocks);
dynamicBobMocks[homepageUrl].delay = 1500;
MockRequests.configureDynamicResponses(dynamicBobMocks);

// Example 2
// Convert all loginMocks entries to dynamic counterparts
const dynamicLoginMocks = Object.keys(loginMocks).reduce((dynamicConfigs, user) => {
    dynamicConfigs[user] = MockRequests.mapStaticConfigToDynamic(loginMocks[user]);
    return dynamicConfigs;
}, {});
MockRequests.configureDynamicResponses(dynamicLoginMocks.bob);

// Example 3
// Merge user-agnostic dynamic mocks with static loginMocks
const dynamicMocks = {
    [searchApiPathname]: {
        dynamicResponseModFn: (req, res, queries) => {
            /* ... same as search query above */
        }
    }
};
const staticDynamicMerged = Object.keys(loginMocks).reduce((dynamicConfigs, user) => {
    dynamicConfigs[user] = {
        ...MockRequests.mapStaticConfigToDynamic(loginMocks[user]),
        ...dynamicMocks
    };
    return dynamicConfigs;
}, {});
MockRequests.configureDynamicResponses(staticDynamicMerged.bob);
</code></pre>
<h2 id="separating-mocks-from-source-code">Separating mocks from source code</h2>
<h3 id="bare-bones-instructions">Bare-bones instructions</h3>
<p>In the simplest, bare-bones example, you could just import <code>MockRequests</code> into one of your entry JavaScript files
(src/index.js, src/App.js, or similar) and configure your mocks there. As long as MockRequests was installed as a
devDependency and you don't commit this code, it will never enter production.</p>
<pre class="prettyprint source lang-javascript"><code>// src/index.js for React project
import React from 'react';
import ReactDOM from 'react-dom';
import App from '/components/App';

import MockRequests from 'mock-requests';

MockRequests.configure(/* ... */);

ReactDOM.render(&lt;App />, document.getElementById('root'));
</code></pre>
<p>However, for larger apps with many network calls or for sharing mocks with other team members, typing and removing
mocks can get quite cumbersome. To simplify this, you could simply move mock-related code to a separate <code>mocks/</code>
folder and only import them when needed. This way, you can commit the mock code to your repo but, just like
test code, it doesn't get deployed into production since it isn't in the src/ folder.
For example, if we have the setup:</p>
<pre class="prettyprint source"><code>MyApp
├─── src/
|   ├─── (... source code)
├─── mocks/
|   ├─── MockConfig.js
|   ├─── StaticResponses.js
|   ├─── DynamicResponseConfigs.js
|   ├─── (... other mock files imported by MockConfig.js)
</code></pre>
<p>where <code>MockConfig.js</code> does all the <code>mock-requests</code> configuration, e.g.</p>
<pre class="prettyprint source lang-javascript"><code>// mocks/MockConfig.js

import MockRequests from 'mock-requests';
import { myStaticApiUrl, myDynamicApiUrl } from '../src/services/Urls.js';
import { myStaticApiResponse } from './StaticResponses'; // Other files in mocks/
import { myDynamicApiConfig } from './DynamicResponseConfigs';

MockRequests.setMockUrlResponse(myStaticApiUrl, myStaticApiResponse);
MockRequests.setDynamicMockUrlResponse(myDynamicApiUrl, myDynamicApiConfig);
</code></pre>
<p>then in your src/index.js file, just import the MockConfig.js file to activate all mocks, and don't commit that
code change to keep all of it out of production:</p>
<pre class="prettyprint source lang-javascript"><code>import React from 'react';
import ReactDOM from 'react-dom';
import App from '/components/App';

import '../mocks/MockConfig';

ReactDOM.render(&lt;App />, document.getElementById('root'));
</code></pre>
<p><a name="webpack-pluginactivating-via-cli"></a></p>
<h3 id="webpack-plugin%2Factivating-via-cli">Webpack Plugin/Activating via CLI</h3>
<p>To avoid having to change your source code to activate/deactivate mocks (e.g. src/index.js above), <code>MockRequests</code> comes with a built-in plugin for projects using <a href="https://webpack.js.org/">webpack</a>. As such, assuming you have a separate directory of mocks and a single mock entry file (see above example), you can simply import the <code>MockRequestsWebpackPlugin</code> and use via:</p>
<pre class="prettyprint source lang-javascript"><code>// webpack.config.js
const MockRequestsWebpackPlugin = require('mock-requests/bin/MockRequestsWebpackPlugin');

module.exports = {
    // ...
    plugins: [
        // ...
         new MockRequestsWebpackPlugin(
            'mocks', // Holds all mock-related files imported by the entry file.
                     // Relative to the webpack &quot;context&quot;/project root (more on this below).
            'MockConfig.js', // Mock entry file, nested inside `mocks/`.
            process.env.MOCK === 'true' // Whether or not mocks should be activated.
        ),
        // ...
    ]
};
</code></pre>
<p>and run using <code>MOCK=true npm start</code>.</p>
<p>Use of this plugin will automatically transpile your code (according to your webpack config's JS/TS rules) and activate mocks based on the boolean of whether or not mocks should be activated. This means you never have to change anything in <code>src/</code> or in webpack.config.js outside of this plugin.</p>
<p>If the boolean condition resolves to <code>false</code>, then nothing will be added to your build output, keeping mock files out of the final production code. In this example, our toggle is via CLI env variable, but it can be anything else of your choosing.</p>
<h4 id="plugin-options">Plugin options</h4>
<p>The webpack plugin comes with a few configuration options to accommodate all types of webpack configurations:</p>
<pre class="prettyprint source lang-javascript"><code>new MockRequestsWebpackPlugin(
    'mocks',
    'MockConfig.js',
    process.env.NODE_ENV === 'development',
    {
        pathsAreAbsolute,  // defaults to `false`
        transpileMocksDir // defaults to `true`
    }
),
</code></pre>
<p>If you prefer using absolute paths instead of relative, then change both the <code>mocksDir</code> and <code>mockEntryFile</code> arguments to be absolute, and set <code>pathsAreAbsolute: true</code>.</p>
<p>If you prefer to nest your <code>mocks/</code> directory inside <code>src/</code> or other directory that's already configured to be transpiled, then set <code>transpileMocksDir: false</code> for added simplicity in webpack processing.</p>
<h3 id="further-customization">Further customization</h3>
<p>If your project doesn't use webpack or if you prefer to have more control over the file-processing, then you could instead use the <code>resolve-mocks.js</code> script to generate the paths to the mock directory/entry-file manually.</p>
<p>All you have to do is pass in the same fields from the <code>MockRequestsWebpackPlugin</code> into the <code>resolveMocks()</code> function, and spread the resulting <code>entry</code>/<code>include</code> arrays where you want them processed. For example:</p>
<pre class="prettyprint source lang-javascript"><code>// webpack.config.js

// Returns an object containing arrays to spread in webpack's `include` and `entry` fields.
// resolveMocks(mockDirectory, mockEntryFile, activateMocksBoolean)
const resolveMocks = require('mock-requests/bin/resolve-mocks');
const resolvedMocks = resolveMocks('mocks', 'mocks/MockConfig.js', process.env.MOCK === 'true');

module.exports = {
    module: {
        rules: [
            {
                test: /\.jsx?$/,
                // adds mocks/ directory to loaders for transpilation
                include: [ /src/, ...resolvedMocks.include ],
                exclude: [ /node_modules/ ],
                loader: 'babel-loader'
            }
        ]
    },
    // adds mocks/MockConfig.js entry file to build output
    entry: [ '@babel/polyfill', './src/index.js', ...resolvedMocks.entry ]
}
</code></pre>
<p>and run using <code>MOCK=true npm start</code>.</p>
<p>Doing so will result in the same outcome of the webpack plugin: transpilation of the <code>mocks/</code> directory so you can write your mocks with the latest JS features, as well as adding the mock entry file to your build/run output dynamically -- all while still being toggled by the CLI. Like the plugin, the mocks won't be added to your build output unless the boolean condition resolves to <code>true</code>.</p>
<h2 id="mockrequests-api">MockRequests API</h2>
<p>In order to make mocking your network calls simpler, config functions have been added to allow for
setting, getting, and deleting mock responses for your network calls.</p>
<p>These are described at length in the <a href="https://d-pow.github.io/MockRequests/MockRequests.html">JSDoc</a>.</p>
<ul>
<li><strong>configure(staticUrlResponseConfigObject, overwritePreviousConfig = true)</strong></li>
<li><strong>configureDynamicResponses(dynamicUrlResponseConfigObject, overwritePreviousConfig = true)</strong></li>
<li><strong>setMockUrlResponse(url, staticMockResponseObject)</strong></li>
<li><strong>setDynamicMockUrlResponse(url, dynamicMockResponseObject)</strong></li>
<li><strong>getResponse(url)</strong></li>
<li><strong>deleteMockUrlResponse(urlNotMeantToBeMocked)</strong></li>
<li><strong>clearAllMocks()</strong></li>
<li><strong>mapStaticConfigToDynamic(staticConfig)</strong></li>
<li><strong>OriginalXHR()</strong></li>
<li><strong>originalFetch()</strong></li>
</ul>
<p>Note that <code>OriginalXHR</code> and <code>originalFetch</code> will use the original <code>XMLHttpRequest</code> and <code>fetch</code> respectively,
regardless of if you've set the mock URL responses in <code>MockRequests.configure()</code> or <code>MockRequests.setMockUrlResponse(...)</code>.
It will also use <code>XMLHttpRequest</code> and <code>fetch</code> regardless of if the browser supports them or not (will be <code>undefined</code> in
cases where the browser doesn't support them).</p>
<h2 id="implementation-notes">Implementation notes</h2>
<ol>
<li>
<p>This mocks the usage of <code>XMLHttpRequest</code> and <code>fetch</code> such that the response is always valid.
This means that the instance attributes below are always set. If you want to change any of these, feel free to do
so within <code>xhr.onreadystatechange</code>/<code>fetch().then(fn)</code>.</p>
<p>For <code>XMLHttpRequest</code>:</p>
<pre class="prettyprint source lang-javascript"><code>xhr.readyState = 4;
xhr.response = mockedResponse;
xhr.responseText = stringVersionOf(mockedResponse); // either JSON.stringify(mockedResponse) or `${mockedResponse}`
xhr.responseUrl = urlPassedInXhrOpenMethod;
xhr.status = 200;
xhr.statusText = 'OK';
xhr.timeout = 0;
</code></pre>
<p>For <code>fetch().then(response =&gt; ...)</code>:</p>
<pre class="prettyprint source lang-javascript"><code>response.status = 200;
response.statusText = '';
response.ok = true;
response.headers = new Headers({ status: '200' });
response.redirected = false;
response.type = 'basic';
</code></pre>
</li>
<li>
<p>This library also works with other members of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API#Fetch_Interfaces">Fetch API</a>,
so you can alternatively use an instance of the <code>Request</code> class in your <code>fetch()</code> calls, e.g. <code>fetch(new Request(url, options))</code>.</p>
</li>
<li>
<p>You may import either the <code>MockRequests</code> default export or any of its individual fields, e.g. <br />
<code>import MockRequests, { setMockUrlResponse } from 'mock-requests';</code></p>
</li>
<li>
<p>This works with any environment that uses either <code>fetch</code> or <code>XMLHttpRequest</code>, regardless of if said
environment is a browser, web/service worker, or a NodeJS script. As long as <code>fetch</code> and/or <code>XMLHttpRequest</code> are defined <strong>globally</strong> (whether natively or
by polyfill), any network request to a URL configured by <code>MockRequests</code> will be
mocked appropriately. For example:</p>
<pre class="prettyprint source lang-javascript"><code>// my-script.js - called via `node my-script.js`
require('isomorphic-fetch');
const MockRequests = require('mock-requests');

// ... use fetch and MockRequests as normal
</code></pre>
</li>
</ol>
<h2 id="license">License</h2>
<p><a href="./LICENSE.md">MIT</a></p></article>
    </section>






    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>